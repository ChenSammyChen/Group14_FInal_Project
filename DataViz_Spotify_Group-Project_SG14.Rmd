---
title: "Data Visualisation & Story Telling - Group Project - Spotify"
author: "Study Group 14"
date: 03/12/2020
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
devtools::install_github("ricardo-bion/ggradar", dependencies=TRUE)
```

```{r loading packages, include=FALSE}
#devtools::install_github("ricardo-bion/ggradar", dependencies = TRUE)
library(Rspotify)
library(ggplot2)
library(tidyverse)
library(janitor)
library(dplyr)
library(skimr)
library(fmsb) # for radar charts
library(ggradar)
library(ggridges)
library(ggiraph)
library(ggiraphExtra)
library(reshape2)
library(moonBook)
library(sjmisc)
library(gridExtra)
library(magick) # for gifs
library(tm)           # TEXT MINING LIBRARY R
library(SnowballC)    # R interface to the C 'libstemmer' stemming library
library(RColorBrewer) # colour pallets for wordcloud
library(wordcloud)    # standard wordcloud
library(wordcloud2)   # fancy wordcloud 
library(rpart.plot)
library(caret)
library(lubridate)
library(Hmisc)
library(readr)
library(gghalves)
#Spotify colours: #1db954(green) and #191414(black) for the Tableau
```

# Introduction
Have you listened to music today? Probably! Music is so present in everyone's life and we're constantly exposed to it everyday, all day.

**But have you ever thought about the data behind the music that you listen to every day?**

Chances are you have used Spotify before. Did you know you could retrieve specific song, album and artist metadata from their Spotify Data Catalouge? Let's have a look at the data behind music on Spotify, one of the biggest music streaming services worldwide. We are going to analyze the audio features, content, time, location, and much more.

It is often difficult for us to describe our music taste - why not visualise it?

**Let us show you music in a completely different light and find out what makes popular music!**

## Spotify API set-up
The tool that we use to retrieve the data is the Spotify API for developers. It allows us to retrieve JSON metadata about music artists, albums, and tracks, directly from the Spotify Data Catalogue.

The instructions we referred to for setting up Spotify API are [here](https://r-music.rbind.io/posts/2018-10-01-rspotify/). You can find more information on the API or set it up yourself on [Spotify for Developers](https://developer.spotify.com). 

```{r set up spotify API}
# set up API connection with personal app_id, client_id, client_secret
# feel free to connect your own account!

# keys <- spotifyOAuth("app_id","client_id","client_secret")
keys <- spotifyOAuth("dataviz","b9bd44a451e94288af529470c5d3ccf0", "c0f6d90ce49d4ded95887bf45c46f958")

# We wil use this key whenever we try to retrieve music from the API
```

```{r check API}
# Using  my own username
user <- getUser("sedroc2015", token = keys)
user$display_name # user name

# check followers
user$followers # :'( no followers
```

## Data

The audio features that we can get from the Spotify metadata and that we will use for the analysis are: 

**Popularity**
- Higher popularity for songs that are being played a lot now compared to songs that were played a lot in the past. Artist and album popularity is derived mathematically from track popularity.

**Properties:**
- Loudness: loud music is usually high in decibels (dB)
- Liveness: detects the presence of audience (more audience higher liveness)
- Speechiness: whether there is presence of spoken works (audio books have a high speechiness)
- Explicit: Whether or not the track has explicit lyrics
- Tempo: whether the overall beats per minute (BPM) is fast or slow
- Duration_ms: track length in milliseconds 

**Mood:**
- Danceability: how suitable a song is for dancing, calculated based on tempo, beat, etc.
- Valence: tracks with high valence sound more positive (happy and cheerful)
- Energy: measure of a trackâ€™s intensity and activity; high energy is typically loud and noisy

**Context**
- Acousticness: whether the music uses acoustic instruments, rather than electrical equipment
- Instrumentalness: whether the music has a lot of instruments or just vocals

# Our own music preferences

Music is heard by people daily in many parts of the world, and affects people in various ways from emotion regulation to cognitive development, along with providing a means for self-expression.

What we listen tells a lot about who we are. Let's start by analyzing our own favourite Spotify playlists to find out the similarities and differences among the five of us.

## Song features

### Marie

- original: https://open.spotify.com/playlist/37i9dQZF1EM22Em6vPrOSO

```{r retrieve playlist}
# Retrieve playlist through API, then retrieve the features of every song with a for loop and create a data set with all the songs and their features

# get playlist
marie_top2020_basic <- getPlaylistSongs("spotify","37i9dQZF1EM22Em6vPrOSO", token =  keys)

# get all features for that playlist

# create data set with any 1 song
marie_top2020_wfeat <- getFeatures("3bH4HzoZZFq8UpZmI2AMgV", token = keys)

# for loop all song ids from the playlist through the getFeatures function
for (i in marie_top2020_basic$id){
  marie_top2020_wfeat <- rbind(marie_top2020_wfeat, getFeatures(i, token = keys))
}
                  
```

```{r fix data}
# Fix playlist data set and delete duplicates

# get rid of first line (that we added to set up the data frame)
marie_top2020_wfeat <- marie_top2020_wfeat[-1,]

# join playlist df and feature df to have all song info in one data set
marie_top2020 <- left_join(marie_top2020_basic, marie_top2020_wfeat, by = "id") 

# fix data set
marie_top2020 <- marie_top2020 %>% 
                  # eliminate irrelevant columns
                  select(-uri, -analysis_url, -time_signature) %>% 
                  # add 1 columns with name for later when joining all of us 
                  cbind("Marie") %>% 
                  # rename that column
                  rename(name = '"Marie"')
```

```{r clean data}
# check if there are duplicates
dupes <- marie_top2020 %>%
  get_dupes(id)

# get rid of duplicates
# marie_top2020 <- marie_top2020 %>%
#  unique()

# check
# dupes <- marie_top2020 %>%
#  get_dupes(id)

# check data 
#head(marie_top2020)
#glimpse(marie_top2020)
#skim(marie_top2020)

```

> Now repeat for everyone else

### Sammy

- original: https://open.spotify.com/playlist/3mkjOvN3TUeazOwk59Jl7X

```{r retrieve playlist Sammy}
# get playlist
sammy_top2020_basic <- getPlaylistSongs("spotify","3mkjOvN3TUeazOwk59Jl7X", token =  keys)

# get all features for that playlist

# create data set with any 1 song
sammy_top2020_wfeat <- getFeatures("3bH4HzoZZFq8UpZmI2AMgV", token = keys)

# for loop all song ids from the playlist through the getFeatures function
for (i in sammy_top2020_basic$id){
  sammy_top2020_wfeat <- rbind(sammy_top2020_wfeat, getFeatures(i, token = keys))
}
                  
# get rid of first line (that we added to set up the data frame)
sammy_top2020_wfeat <- sammy_top2020_wfeat[-1,]

# join playlist df and feature df to have all song info in one data set
sammy_top2020 <- left_join(sammy_top2020_basic, sammy_top2020_wfeat, by = "id") 

# fix data set
sammy_top2020 <- sammy_top2020 %>% 
                  # eliminate irrelevant columns
                  select(-uri, -analysis_url, -time_signature) %>% 
                  # add 1 columns with name for later when joining all of us 
                  cbind("Sammy") %>% 
                  # rename that column
                  rename(name = '"Sammy"')

# check if there are duplicates
dupes <- sammy_top2020 %>%
  get_dupes(id)

# check data 
#head(sammy_top2020)
#glimpse(sammy_top2020)
#skim(sammy_top2020)

```

### Ruchen

- original: https://open.spotify.com/playlist/3ncHsEr99JsKoZzgvE6EJ9

```{r retrieve playlist Ruchen}
# get playlist
ruchen_top2020_basic <- getPlaylistSongs("spotify","3ncHsEr99JsKoZzgvE6EJ9", token =  keys)

# get all features for that playlist

# create data set with any 1 song
ruchen_top2020_wfeat <- getFeatures("3bH4HzoZZFq8UpZmI2AMgV", token = keys)

# for loop all song ids from the playlist through the getFeatures function
for (i in ruchen_top2020_basic$id){
  ruchen_top2020_wfeat <- rbind(ruchen_top2020_wfeat, getFeatures(i, token = keys))
}
                  
# get rid of first line (that we added to set up the data frame)
ruchen_top2020_wfeat <- ruchen_top2020_wfeat[-1,]

# join playlist df and feature df to have all song info in one data set
ruchen_top2020 <- left_join(ruchen_top2020_basic, ruchen_top2020_wfeat, by = "id") 

# fix data set
ruchen_top2020 <- ruchen_top2020 %>% 
                  # eliminate irrelevant columns
                  select(-uri, -analysis_url, -time_signature) %>% 
                  # add 1 columns with name for later when joining all of us 
                  cbind("Ruchen") %>% 
                  # rename that column
                  rename(name = '"Ruchen"')

# check if there are duplicates
dupes <- ruchen_top2020 %>%
  get_dupes(id)

# check data 
#head(ruchen_top2020)
#glimpse(ruchen_top2020)
#skim(ruchen_top2020)
```

### Filippo

- original: https://open.spotify.com/playlist/37i9dQZF1EtsyZafU4Vjrk

```{r retrieve playlist Filippo}
# get playlist
filippo_top2020_basic <- getPlaylistSongs("spotify","37i9dQZF1EtsyZafU4Vjrk", token =  keys)

# get all features for that playlist

# create data set with any 1 song
filippo_top2020_wfeat <- getFeatures("3bH4HzoZZFq8UpZmI2AMgV", token = keys)

# for loop all song ids from the playlist through the getFeatures function
for (i in filippo_top2020_basic$id){
  filippo_top2020_wfeat <- rbind(filippo_top2020_wfeat, getFeatures(i, token = keys))
}
                  
# get rid of first line (that we added to set up the data frame)
filippo_top2020_wfeat <- filippo_top2020_wfeat[-1,]

# join playlist df and feature df to have all song info in one data set
filippo_top2020 <- left_join(filippo_top2020_basic, filippo_top2020_wfeat, by = "id") 

# fix data set
filippo_top2020 <- filippo_top2020 %>% 
                  # eliminate irrelevant columns
                  select(-uri, -analysis_url, -time_signature) %>% 
                  # add 1 columns with name for later when joining all of us 
                  cbind("Filippo") %>% 
                  # rename that column
                  rename(name = '"Filippo"')

# check if there are duplicates
dupes <- filippo_top2020 %>%
  get_dupes(id)

# check data 
#head(filippo_top2020)
#glimpse(filippo_top2020)
#skim(filippo_top2020)

```

### Jason

- original: https://open.spotify.com/playlist/37i9dQZF1EM60SaMcpGdCv

```{r retrieve playlist Jason}
# get playlist
jason_top2020_basic <- getPlaylistSongs("spotify","37i9dQZF1EM60SaMcpGdCv", token =  keys)

jason_top2020_basic <- jason_top2020_basic %>%
  unique()
# get all features for that playlist

# create data set with any 1 song
jason_top2020_wfeat <- getFeatures("3bH4HzoZZFq8UpZmI2AMgV", token = keys)

# for loop all song ids from the playlist through the getFeatures function
for (i in jason_top2020_basic$id){
  jason_top2020_wfeat <- rbind(jason_top2020_wfeat, getFeatures(i, token = keys))
}
                  
# get rid of first line (that we added to set up the data frame)
jason_top2020_wfeat <- jason_top2020_wfeat[-1,]

# join playlist df and feature df to have all song info in one data set
jason_top2020 <- left_join(jason_top2020_basic, jason_top2020_wfeat, by = "id") 

# fix data set
jason_top2020 <- jason_top2020 %>% 
                  # eliminate irrelevant columns
                  select(-uri, -analysis_url, -time_signature) %>% 
                  # add 1 columns with name for later when joining all of us 
                  cbind("Jason") %>% 
                  # rename that column
                  rename(name = '"Jason"')

# check if there are duplicates
dupes <- jason_top2020_wfeat %>%
  get_dupes(id)

# check data 
#head(jason_top2020)
#glimpse(jason_top2020)
#skim(jason_top2020)

```

### Plot

```{r marie_rc}
marie_rc <- marie_top2020 %>% 
  select(danceability, valence, speechiness, instrumentalness, acousticness, liveness, energy) %>% 
  ggRadar(colour = "#8000FF",
          # transparency
          alpha = 0.8, 
          # get rid of points
          size = 0,
          # set y axis limits
          ylim = c(0,1))+
  labs(title = "Marie",
       x = "",
       y = "",
       caption = "Source: https://developer.spotify.com") +
  # edit theme
  theme(text = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        plot.title = element_text(size = 15, family = "Helvetica Neue Bold", hjust = 0.5),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light"),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_line(colour = "#f2f2f2", 
                                  size = 0.15, 
                                  linetype = 2),
        plot.background = element_rect(fill = "#191414"),
        panel.background = element_rect(fill = "#191414"),
        legend.position = "none",
        )+
NULL
```

```{r ruchen_rc}
ruchen_rc <- ruchen_top2020 %>% 
  select(danceability, valence, speechiness, instrumentalness, acousticness, liveness, energy) %>% 
  ggRadar(colour = "#FF0080",
          # transparency
          alpha = 0.8, 
          # get rid of points
          size = 0,
          # set y axis limits
          ylim = c(0,1))+
  labs(title = "Ruchen",
       x = "",
       y = "",
       caption = "Source: https://developer.spotify.com") +
  # edit theme
  theme(text = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        plot.title = element_text(size = 15, family = "Helvetica Neue Bold", hjust = 0.5),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light"),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_line(colour = "#f2f2f2", 
                                  size = 0.15, 
                                  linetype = 2),
        plot.background = element_rect(fill = "#191414"),
        panel.background = element_rect(fill = "#191414"),
        legend.position = "none")+
NULL
```

```{r sammy_rc}
sammy_rc <- sammy_top2020 %>% 
  select(danceability, valence, speechiness, instrumentalness, acousticness, liveness, energy) %>% 
  ggRadar(colour = "#ffff00",
          # transparency
          alpha = 0.8, 
          # get rid of points
          size = 0,
          # set y axis limits
          ylim = c(0,1))+
  labs(title = "Sammy",
       x = "",
       y = "",
       caption = "Source: https://developer.spotify.com") +
  # edit theme
  theme(text = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        plot.title = element_text(size = 15, family = "Helvetica Neue Bold", hjust = 0.5),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light"),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_line(colour = "#f2f2f2", 
                                  size = 0.15, 
                                  linetype = 2),
        plot.background = element_rect(fill = "#191414"),
        panel.background = element_rect(fill = "#191414"),
        legend.position = "none")+
NULL
```

```{r filippo_rc}
filippo_rc <- filippo_top2020 %>% 
  select(danceability, valence, speechiness, instrumentalness, acousticness, liveness, energy) %>% 
  ggRadar(colour = "#00FF80",
          # transparency
          alpha = 0.8, 
          # get rid of points
          size = 0,
          # set y axis limits
          ylim = c(0,1))+
  labs(title = "Filippo",
       x = "",
       y = "",
       caption = "Source: https://developer.spotify.com") +
  # edit theme
  theme(text = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        plot.title = element_text(size = 15, family = "Helvetica Neue Bold", hjust = 0.5),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light"),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_line(colour = "#f2f2f2", 
                                  size = 0.15, 
                                  linetype = 2),
        plot.background = element_rect(fill = "#191414"),
        panel.background = element_rect(fill = "#191414"),
        legend.position = "none")+
NULL
```

```{r jason_rc}
jason_rc <- jason_top2020 %>% 
  select(danceability, valence, speechiness, instrumentalness, acousticness, liveness, energy) %>% 
  ggRadar(colour = "#00FFFF",
          # transparency
          alpha = 0.8, 
          # get rid of points
          size = 0,
          # set y axis limits
          ylim = c(0,1))+
  labs(title = "Jason",
       x = "",
       y = "",
       caption = "Source: https://developer.spotify.com") +
  # edit theme
  theme(text = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        plot.title = element_text(size = 15, family = "Helvetica Neue Bold", hjust = 0.5),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light"),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_line(colour = "#f2f2f2", 
                                  size = 0.15, 
                                  linetype = 2),
        plot.background = element_rect(fill = "#191414"),
        panel.background = element_rect(fill = "#191414"),
        legend.position = "none")+
NULL
```

```{r all rc}
#grid.arrange(filippo_rc, jason_rc, marie_rc, ruchen_rc, sammy_rc, nrow = 3)
filippo_rc
jason_rc
marie_rc
ruchen_rc
sammy_rc
```

```{r rc gif}
# save each chart as jpeg
# filippo_rc + ggsave('filippo_rc.jpeg', height = 5, width = 5, units = 'in')
# jason_rc + ggsave('jason_rc.jpeg', height = 5, width = 5, units = 'in')
# marie_rc + ggsave('marie_rc.jpeg', height = 5, width = 5, units = 'in')
# ruchen_rc + ggsave('ruchen_rc.jpeg', height = 5, width = 5, units = 'in')
#sammy_rc + ggsave('sammy_rc.jpeg', height = 5, width = 5, units = 'in')
```

Looks like our music tastes are quite similar? Filippo seems to enjoy energetic music more whereas Jason seems to like acoustic music.

## Popularity & Pace

Next, we want to directly compare our music taste in terms of how popular the songs are that we listen to and how fast the tempo (in beats per minute) is. Let's look at our differences! (or similarities?)

```{r combined dataset}
# combine data sets
spotify_all <- marie_top2020 %>% 
                rbind(sammy_top2020) %>% 
                rbind(ruchen_top2020) %>% 
                rbind(filippo_top2020) %>% 
                rbind(jason_top2020)

# check data sets
glimpse(spotify_all)
skim(spotify_all)

```

### Tempo

```{r tempo}
levels <- c("Sammy","Ruchen", "Marie", "Jason","Filippo")
favcolours <- c("#ffff00", "#FF0080", "#8000FF", "#00FFFF", "#00FF80")
label <- ("Filippo likes songs\nwith the same tempo")



tempo <- spotify_all %>% 
  mutate(name = factor(name, levels = levels)) %>% 
  ggplot(aes(x = tempo, y = name, fill = name, colour = name))+
  geom_density_ridges(alpha = 0.4) +
  # add labels
  labs(title = "Not too fast and not too slow",
       subtitle = "Beats per minute (BPM) distribution of our favourite songs per person",
       x = "Tempo in BPM",
       y = "",
       caption = "Source: https://developer.spotify.com") +
  # edit colours
  scale_fill_manual(values = favcolours)+
  scale_colour_manual(values = favcolours)+
  # edit theme
  theme(text = element_text(colour = "white", size = 11, family = "Helvetica Neue Light"),
        plot.title = element_text(size = 15, family = "Helvetica Neue Bold"),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light"),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Medium"),
        axis.text.x = element_text(colour = "white"),
        axis.text.y = element_text(colour = "white", size = 12, family = "Helvetica Neue Bold"),
        axis.ticks = element_blank(),
        panel.grid = element_blank(),
        plot.background = element_rect(fill = "#191414"),
        panel.background = element_rect(fill = "#191414"),
        plot.margin=grid::unit(c(0,0,0,0), "mm"),
        legend.position = "none")+
  # add descriptive text
   geom_text(data = data.frame(x = 50, y = 5.5, label = label),
          aes(x = x, y = y, label = label),
          colour="white",
          family="Helvetica Neue Medium",
          size = 3,
          inherit.aes = FALSE
          )+
   # add arrow
   geom_curve(aes(x = 60, y = 5.85, xend = 110, yend = 6.3),
              arrow = arrow(length = unit(0.04, "npc")),
              colour = "white",
              curvature = -0.4,
              size = 0.2)+
  NULL

tempo
#tempo + ggsave('tempo.jpeg')
```

### Popularity

```{r popularity}
levels <- c("Sammy","Ruchen", "Marie", "Jason","Filippo")
favcolours <- c("#ffff00", "#FF0080", "#8000FF", "#00FFFF", "#00FF80")
label2 <- ("Marie enjoys\nunknown songs")



popularity <- spotify_all %>% 
  mutate(name = factor(name, levels = levels)) %>% 
  ggplot(aes(x = popularity, y = name, fill = name, colour = name))+
  geom_density_ridges(alpha = 0.4) +
  # add labels
  labs(title = "How mainstream are our favourite songs?",
       subtitle = "Popularity distribution of our favourite songs per person",
       x = "Song popularity",
       y = "",
       caption = "Source: https://developer.spotify.com") +
  # edit colours
  scale_fill_manual(values = favcolours)+
  scale_colour_manual(values = favcolours)+
  # edit x axes
  scale_x_continuous(breaks = c(0,100),
                     labels = c("Unknown", "Most popular"))+
  # edit theme
  theme(text = element_text(colour = "white", size = 11, family = "Helvetica Neue Light"),
        plot.title = element_text(size = 15, family = "Helvetica Neue Bold"),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light"),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_text(colour = "white", size = 12, family = "Helvetica Neue Bold"),
        axis.ticks = element_blank(),
        panel.grid = element_blank(),
        plot.background = element_rect(fill = "#191414"),
        panel.background = element_rect(fill = "#191414"),
        plot.margin=grid::unit(c(1,1,1,1), "mm"),
        legend.position = "none")+
  # add descriptive text
   geom_text(data = data.frame(x = 0, y = 1.5, label = label2),
          aes(x = x, y = y, label = label2),
          colour="white",
          family="Helvetica Neue Medium",
          size = 3,
          inherit.aes = FALSE
          )+
   # add arrow
   geom_curve(aes(x = 11, y = 1.6, xend = 5, yend = 3.2),
              arrow = arrow(length = unit(0.04, "npc")),
              colour = "white",
              curvature = 0.4,
              size = 0.2)+
  NULL

popularity
# popularity + ggsave('popularity.jpeg')
```

Now we know that Filippo seems to like all of his songs to have the same tempo. Ruchen, Filippo and Marie seem to enjoy rather unknown songs as well!

Nevertheless, we are just a small sample of Spotify listeners. 

> But what makes a song popular? Surely the most popular playlist on Spotify will tell us!

# Song popularity

## Today's Top 100

Maybe we can better understand music popularity through the most listened to playlist on Spotify, [Today's Top Hits](https://open.spotify.com/playlist/37i9dQZF1DXcBWIGoYBM5M). 

Let's check today's most popular songs from Spotify and use the audio features mentioned above to find out why todayâ€™s top hits are the most popular and if there are any differences in what a song sounds like depending on the artist's genre.

As we wanted to explore gender dynamics for artist, we retrieved the playlist from the API but then manually imputed gender dynamics onto the data set as Spotify does not provide any demographic information on artists.

```{r top 100 dimension distribution}
popular <- read_csv("popular.csv")

popular<-janitor::clean_names(popular)

pp<-popular%>%
  select(id,valence,acousticness,danceability,energy,instrumentalness,liveness,speechiness,artist_gender)%>%
  pivot_longer(cols=!c(id,artist_gender), names_to="measure",values_to="count")%>%
  group_by(measure) %>%
  mutate(measure = fct_reorder(measure,count,.fun='median'))

box_pop <- ggplot(data=pp,aes(x=reorder(measure,desc(count)),y=count,color=as.factor(artist_gender), fill=as.factor(artist_gender)))+
  geom_half_boxplot(data=pp%>%filter(artist_gender=="Male"),side = "l")+
  geom_half_boxplot(data=pp%>%filter(artist_gender=="Female"),side = "r")+
scale_fill_manual(values = c("#191414","#191414"))+
scale_color_manual(values = c("#bc13fe","#1DB954"))+
  theme(text = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        plot.title = element_text(size = 16, family = "Helvetica Neue Bold", hjust = 0),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light", hjust = 0),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        axis.line = element_line(linetype = 1, colour = "grey80"),
        axis.ticks = element_blank(),
        panel.grid = element_blank(),
        plot.background = element_rect(fill = "#191414"),
        panel.background = element_rect(fill = "#191414"),
        legend.background =element_rect(fill = "#191414"),
        legend.box.background = element_rect(fill = "#191414", colour = "#191414"),
        legend.key = element_rect(fill = "#191414"),
        legend.position = "top"
        )+
  scale_y_continuous(breaks = c(0,1),
                     labels = c("0%", "100%"))+
  labs(title = "Popular Music is all about Danceability and Energy", 
       subtitle = "No one cares about the instrument you play",
       x = "",
       y = "",
       colour="",
       fill="",
       caption = "Source: https://developer.spotify.com")

box_pop
# box_pop + ggsave('boxplot_of_top_songs.jpeg', units = 'in')

```

Seems like popular music is all about the danceability and energy of a track. Today's popular songs seem to not be recorded live or involve many instruments. It is also interesting to see that songs from female artists seem to overall be happier (higher valence) and more acoustic than those of male artists.

> But this is only what makes todayâ€™s music popular. Letâ€™s see which factors are most important in determining popularity overall!

## Predicting popularity 

We want to find out which features play a key part in determining popularity on a more representative dataset.

We use a [data set](https://www.kaggle.com/yamaerenay/spotify-dataset-19212020-160k-tracks/discussion) that contains audio features and information on more than 170,000 songs released between 1921 and 2020 collected from the Spotify Web API. Each row of data contains the following information:

- `id` (unique track id generated by Spotify)
- `name` (Name of the song)
- `artists` (List of song artists)
- `release_date` (Date of release mostly in yyyy-mm-dd format, however precision of date may vary)
- `year` (Ranges from 1921 to 2020)
- `duration_ms` (Integer typically ranging from 200k to 300k)
- `tempo` (Float typically ranging from 50 to 150)
- `key` (All keys on octave encoded as values ranging from 0 to 11, starting on C as 0, C# as 1 and so onâ€¦)
- `mode` (Musical scale of song, 0 = Minor, 1 = Major)
- `explicit` (0 = No explicit content, 1 = Explicit content)
- `acousticness` (Ranges from 0 to 1)

Audio features as explained before: 
- `danceability` (Ranges from 0 to 1)
- `energy` (Ranges from 0 to 1)
- `instrumentalness` (Ranges from 0 to 1)
- `valence` (Ranges from 0 to 1)
- `popularity` (Ranges from 0 to 100)
- `liveness` (Ranges from 0 to 1)
- `loudness` (Float typically ranging from -60 to 0)
- `speechiness` (Ranges from 0 to 1)

Based on this dataset we run a regression analysis with popularity as the dependent variable to understand what determines popularity.

```{r regression analysis}
data<- read_csv("data_all.csv")

set.seed(1)
library(rsample)
train_test_split <- initial_split(data, prop = 0.8) #training set contains 75% of the data
# Create the training dataset
train_data <- training(train_test_split)
test_data <- testing(train_test_split)

control <- trainControl (
  method="cv",
  number=5,
  verboseIter=TRUE) #by setting this to true the model will report its progress after each estimation

#we are going to train the model and report the results using k-fold cross validation
model1_lm<-train(
  (popularity)~valence+acousticness+danceability+duration_ms+energy+explicit+instrumentalness+liveness+loudness+speechiness+tempo,
  train_data,
  method = "lm",
  trControl = control)

summary(model1_lm)

importance <- varImp(model1_lm, scale=TRUE)

# create feature importance map

# saved importance feature values
varImp <- read_csv("varImp.csv")

skimr::skim(varImp)

colours <- c("#1DB954", "#1DB954", "#1DB954", "#bc13fe", "#1DB954", "#1DB954", "#bc13fe", "#1DB954", "#bc13fe", "#bc13fe", "#bc13fe")

featimportance <- varImp%>%
  arrange(importance) %>%
  mutate(type = factor(type, levels=c("duration_ms","tempo", "loudness","liveness","energy","explicit","instrumentalness","danceability","valence","speechiness","acousticness"))) %>%ggplot(aes(x=reorder(type,desc(importance)),y=importance))+
  geom_segment(aes(x=type,xend=type,y=0,yend=importance),color=colours)+geom_point(size=4, color=colours)+
  coord_flip() +
  theme(text = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        plot.title = element_text(size = 16, family = "Helvetica Neue Bold", hjust = 0),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light", hjust = 0),
        plot.caption = element_text(size = 9, family = "Helvetica Neue Light", hjust = 1),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        axis.line = element_line(linetype = 1, colour = "grey80"),
        panel.grid = element_blank(),
        plot.background = element_rect(fill = "#191414"),
        panel.background = element_rect(fill = "#191414"),
        legend.background =element_rect(fill = "#191414"),
        legend.box.background = element_rect(fill = "#191414"),
        legend.key = element_rect(fill = "#191414"),
        legend.position = "top")+
  labs(title = "Produce a danceable song for success,\nmake an acoustic, happy song for failure", 
       subtitle = "Feature importance* of linear regression model",
       caption = "*Positive influence in green, negative in pink\nSource: https://developer.spotify.com",
       x = "",
       y = "Importance",
       color="",
       fill="")+
  NULL

featimportance
```

It seems like acousticness and speechiness and valence have the highest influence on song popularity. According to our mode, acousticness and speechiness should be kept to a minimum and the song should not be too happy or make use of many instruments. Rather, songs that are highly danceable and energetic as well as include explicit language seem to be born for success!

While we can generate a model with all features being highly significant, we can only explain about half of the variance in our data.

> Unfortunately, song popularity isnâ€™t this simple. We have to take more factors into considerationâ€¦ 

Let's have a look at 4 factors that influence music taste and preferences!

> Content, genres, time & location

## Content

First, we try to understand the content behind a song. For that, we use text mining on Spotify's [Top 50 World](https://open.spotify.com/playlist/2nbZ56KHmaU7THqwuInhxd) playlist to understand what are the most frequently appeared words.
             
```{r by content analysis}
# Construct path to a folder where our songs' corpus will be built
yourPath <- "Lyrics_groupproject"
name <- file.path(yourPath)
length(dir(name)) 
dir(name) 

# Creating corpus 
# tm package function: store corpus into variable called 'original' 
original <- Corpus(DirSource(name)) 
# create a new variable called docs
docs <- original 

# Short summary of Corpus
typeof(docs) # "list"
class(docs)  # "SimpleCorpus" "Corpus"      

length(docs) # 48
show(docs)
# <<SimpleCorpus>>
# Metadata:  corpus specific: 1, document level (indexed): 0
# Content:  documents: 48
summary(docs)
#             Length Class             Mode
# 34+35 - Ariana grande.txt                      2      PlainTextDocument list
# ALWAYS DO - The Kid Laroi.txt                  2      PlainTextDocument list
# Angels Like You - Miley Cyrus.txt              2      PlainTextDocument list
# At My Worst - Pink Sweat$.txt                  2      PlainTextDocument list
# Bichota - KAROL F.txt                          2      PlainTextDocument list
# Blinding Lights - The Weeknd.txt               2      PlainTextDocument list
# Body - Megan Thee Stallion.txt                 2      PlainTextDocument list
# Breaking - Topic.txt                           2      PlainTextDocument list
# many more...


# Inspecting documents
docs[[1]]$content # 1st doc' actual word content
docs[[1]]$meta    # additional meta data which gets created during analysis (we won't need this)


# Transformations of corpus text 
docs <- tm_map(docs, tolower) # tm package function
inspect(docs[[1]])

docs <- tm_map(docs, removeNumbers)
inspect(docs[[1]])

stopwords("english")
docs <- tm_map(docs, removeWords, stopwords("english"))
inspect(docs[[1]])

docs <- tm_map(docs, removePunctuation)
inspect(docs[[1]])

docs <- tm_map(docs, stripWhitespace)
inspect(docs[[1]])

# remove irrelevant words 
# dont remove "like" as it can also mean "to like something"
words <- c("con", "dadadadadada","lalalala","tÃ£Â°", "pumpum", "que", "get", "let", "one", "two", "three", "four","can","got","cause","now","just")
docs <- tm_map(docs, removeWords, words)
inspect(docs[[1]])


# Examine 1st document CONTENT after transformations
text1 <- docs[[1]]$content 
# Let's check the data type of this variable
typeof(text1) # 'character' 
length(text1) # 1 i.e. it is a single string of all words in that document
print(text1)
class(docs)      # "SimpleCorpus" "Corpus"      
class(docs[[1]]) # "PlainTextDocument" "TextDocument"   

# Create Document Term Matrix 
# Use term frequency (TF) to create the matrix
library(tm)
DTM <- DocumentTermMatrix(docs) 
dim(DTM) # 48 (docs / rows) x 2167 (words / cols) 
print(DTM)
# <<DocumentTermMatrix (documents: 48, terms: 2167)>>
# Non-/sparse entries: 3750/100266
# Sparsity           : 96% 
# Maximal term length: 32
# Weighting          : term frequency (tf)
inspect(DTM[, 1:5]) 

# Convert to tibble
m <- as.matrix(DTM)
# from=x, to=y, by=z i.e. in steps of 1
year <- seq(0, 100, 1) 
# bind column called year, and other columns in matrix into a single matrix M
M <- cbind(year, m) 
# transform matrix into tibble
DTM_tbl <- as_tibble(m) 
DTM_tbl_tidy <- pivot_longer(DTM_tbl, cols = !year, names_to = "word", values_to = "wordCount")

# Analysis
# 1) total count
# number of words in each doc
# Tidyverse approach
totCount <- DTM_tbl_tidy %>%  
        group_by(year) %>% 
        summarise(total = sum(wordCount)) %>% 
        arrange(desc(total)) 
print(totCount)


# Base R approach:
tot <- rowSums(as.matrix(DTM))
totCount <- sort(tot, decreasing = TRUE) 
print(totCount)

# 2) Word frequency 
# Number of times each word occurred across all documents
# Tidyverse approach
wordCountDoc <- DTM_tbl_tidy %>%  
        group_by(word) %>% 
        summarise(total = sum(wordCount)) %>% 
        arrange(desc(total)) 
print(wordCountDoc)


# Base R approach:
freq <- colSums(as.matrix(DTM)) 
wordCountDoc2 <- sort(freq, decreasing = TRUE) 
print(wordCountDoc2[1:10]) # obtain a slice of vector 'wordCountDoc' starting from element 1 to 10

# 3) Word frequency table 
wordFreqTable <- table(wordCountDoc2)
head(wordFreqTable) 
tail(wordFreqTable)


# 4) N word occurances 
# Find which words occurred at least 125 times
top_n <- findFreqTerms(DTM, 125)
print(top_n)
# "know" "like" "yeah"

# word clouds

# figPaths = system.file("spotify.png",package = "wordcloud2")
wordcloud <- wordcloud2(wordCountDoc, color = rep_len(c("#00FF80", "#ffff00", "#FF0080", "#8000FF", "#00FFFF"),nrow(wordCountDoc)), backgroundColor = "#191414") 

wordcloud

library("htmlwidgets")
saveWidget(wordcloud,"tmp.html",selfcontained = F)

```

We can see that for the most popular songs at the moment, **yeah**, **like** and **know** are the most used words in song lyrics. Plotting these for different genres will yield many similar words but surely also large differences in the words.

Overall, next to the music and its features, the lyrics and their meaning play a great role when it comes to listening to music. People often like songs or artists which they can relate or which describe a feeling that they desire. Thereby, the lyrics of a song can say a lot about the emotions and situation of both the artist and the listener.

On the other hand, many emotions and thoughts are expressed through the music and the melodies themselves. Let's have a look at how the audio features differ per genre.

## Genres

Music preferences differ highly by genre as genres often correspond to listeners' mood or social identity. Here we choose 6 of the most popular and most identifiable genres to see the differences in their song features. 

We use the following playlists:

- [Indie](https://open.spotify.com/playlist/37i9dQZF1DX2Nc3B70tvx0)

- [Hiphop](https://open.spotify.com/playlist/37i9dQZF1DWT5MrZnPU1zD)

- [Classical](https://open.spotify.com/playlist/37i9dQZF1DWWEJlAGA9gs0)

- [Rock](https://open.spotify.com/playlist/37i9dQZF1DWXRqgorJj26U)

- [Metal](https://open.spotify.com/playlist/37i9dQZF1DX9qNs32fujYe)

- [Country](https://open.spotify.com/playlist/37i9dQZF1DX1lVhptIYRda)

We do not add a **Pop** playlist as the previously discussed Top Hits Today playlist is from the pop genre.

### Indie

```{r indie}
# get playlist
indie_basic <- getPlaylistSongs("spotify","37i9dQZF1DX2Nc3B70tvx0", token =  keys)

indie_basic <- indie_basic %>%
  unique()
# get all features for that playlist

# create data set with any 1 song
indie_wfeat <- getFeatures("3bH4HzoZZFq8UpZmI2AMgV", token = keys)

# for loop all song ids from the playlist through the getFeatures function
for (i in indie_basic$id){
  indie_wfeat <- rbind(indie_wfeat, getFeatures(i, token = keys))
}
                  
# get rid of first line (that we added to set up the data frame)
indie_wfeat <- indie_wfeat[-1,]

# join playlist df and feature df to have all song info in one data set
indie <- left_join(indie_basic, indie_wfeat, by = "id") 

# fix data set
indie <- indie %>% 
                  # eliminate irrelevant columns
                  select(-uri, -analysis_url, -time_signature) %>% 
                  # add 1 columns with name for later when joining all of us 
                  cbind("Indie") %>% 
                  # rename that column
                  rename(name = '"Indie"')

# check if there are duplicates
dupes <- indie_wfeat %>%
  get_dupes(id)

#plot radar chart
indie_rc <- indie %>% 
  select(danceability, valence, speechiness, instrumentalness, acousticness, liveness, energy) %>% 
  ggRadar(colour = "white",
          # transparency
          alpha = 0.8, 
          # get rid of points
          size = 0,
          # set y axis limits
          ylim = c(0,1))+
  labs(title = "Indie",
       caption = "Source: https://developer.spotify.com",
       x = "",
       y = "")+
  # edit theme
  theme(text = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        plot.title = element_text(size = 30, family = "Helvetica Neue Bold", hjust = 0),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light", hjust = 0.5),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        plot.margin=grid::unit(c(1,1,0.5,0.5), "cm"),
        panel.grid = element_line(colour = "#f2f2f2", 
                                  size = 0.4, 
                                  linetype = 2),
        plot.background = element_rect(fill = "#5786D0"),
        panel.background = element_rect(fill = "#5786D0"),
        legend.position = "none")+
NULL
```

### Hip Hop

```{r hip hop}
# get playlist
hiphop_basic <- getPlaylistSongs("spotify","37i9dQZF1DWT5MrZnPU1zD", token =  keys)

hiphop_basic <- hiphop_basic %>%
  unique()
# get all features for that playlist

# create data set with any 1 song
hiphop_wfeat <- getFeatures("3bH4HzoZZFq8UpZmI2AMgV", token = keys)

# for loop all song ids from the playlist through the getFeatures function
for (i in hiphop_basic$id){
  hiphop_wfeat <- rbind(hiphop_wfeat, getFeatures(i, token = keys))
}
                  
# get rid of first line (that we added to set up the data frame)
hiphop_wfeat <- hiphop_wfeat[-1,]

# join playlist df and feature df to have all song info in one data set
hiphop <- left_join(hiphop_basic, hiphop_wfeat, by = "id") 

# fix data set
hiphop <- hiphop %>% 
                  # eliminate irrelevant columns
                  select(-uri, -analysis_url, -time_signature) %>% 
                  # add 1 columns with name for later when joining all of us 
                  cbind("Hip Hop") %>% 
                  # rename that column
                  rename(name = '"Hip Hop"')

# check if there are duplicates
dupes <- hiphop_wfeat %>%
  get_dupes(id)

hiphop_rc <- hiphop %>% 
  select(danceability, valence, speechiness, instrumentalness, acousticness, liveness, energy) %>% 
  ggRadar(colour = "white",
          # transparency
          alpha = 0.8, 
          # get rid of points
          size = 0,
          # set y axis limits
          ylim = c(0,1))+
  labs(title = "Hip Hop",
      caption = "Source: https://developer.spotify.com",
       x = "",
       y = "") +
  # edit theme
  theme(text = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        plot.title = element_text(size = 30, family = "Helvetica Neue Bold", hjust = 0),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light", hjust = 0.5),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        plot.margin=grid::unit(c(1,1,0.5,0.5), "cm"),
        panel.grid = element_line(colour = "#f2f2f2", 
                                  size = 0.4, 
                                  linetype = 2),
        plot.background = element_rect(fill = "#4D796A"),
        panel.background = element_rect(fill = "#4D796A"),
        legend.position = "none")+
NULL
```

### Rock

```{r rock}
rock_basic <- getPlaylistSongs("spotify","37i9dQZF1DWXRqgorJj26U", token =  keys)

rock_basic <- rock_basic %>%
  unique()
# get all features for that playlist

# create data set with any 1 song
rock_wfeat <- getFeatures("3bH4HzoZZFq8UpZmI2AMgV", token = keys)

# for loop all song ids from the playlist through the getFeatures function
for (i in rock_basic$id){
  rock_wfeat <- rbind(rock_wfeat, getFeatures(i, token = keys))
}
                  
# get rid of first line (that we added to set up the data frame)
rock_wfeat <- rock_wfeat[-1,]

# join playlist df and feature df to have all song info in one data set
rock <- left_join(rock_basic, rock_wfeat, by = "id") 

# fix data set
rock <- rock %>% 
                  # eliminate irrelevant columns
                  select(-uri, -analysis_url, -time_signature) %>% 
                  # add 1 columns with name for later when joining all of us 
                  cbind("rock") %>% 
                  # rename that column
                  rename(name = '"rock"')

# check if there are duplicates
dupes <- rock_wfeat %>%
  get_dupes(id)

rock_rc <- rock %>% 
  select(danceability, valence, speechiness, instrumentalness, acousticness, liveness, energy) %>% 
  ggRadar(colour = "white",
          # transparency
          alpha = 0.8, 
          # get rid of points
          size = 0,
          # set y axis limits
          ylim = c(0,1))+
  labs(title = "Rock",
       caption = "Source: https://developer.spotify.com",
       x = "",
       y = "") +
  # edit theme
  theme(text = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        plot.title = element_text(size = 30, family = "Helvetica Neue Bold", hjust = 0),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light", hjust = 0.5),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        plot.margin=grid::unit(c(1,1,0.5,0.5), "cm"),
        panel.grid = element_line(colour = "#f2f2f2", 
                                  size = 0.4, 
                                  linetype = 2),
        plot.background = element_rect(fill = "#C95C3B"),
        panel.background = element_rect(fill = "#C95C3B"),
        legend.position = "none")+
NULL

```

### Classical

```{r classical}

classical_basic <- getPlaylistSongs("spotify","37i9dQZF1DWWEJlAGA9gs0", token =  keys)

classical_basic <- classical_basic %>%
  unique()
# get all features for that playlist

# create data set with any 1 song
classical_wfeat <- getFeatures("3bH4HzoZZFq8UpZmI2AMgV", token = keys)

# for loop all song ids from the playlist through the getFeatures function
for (i in classical_basic$id){
  classical_wfeat <- rbind(classical_wfeat, getFeatures(i, token = keys))
}
                  
# get rid of first line (that we added to set up the data frame)
classical_wfeat <- classical_wfeat[-1,]

# join playlist df and feature df to have all song info in one data set
classical <- left_join(classical_basic, classical_wfeat, by = "id") 

# fix data set
classical <- classical %>% 
                  # eliminate irrelevant columns
                  select(-uri, -analysis_url, -time_signature) %>% 
                  # add 1 columns with name for later when joining all of us 
                  cbind("Classical") %>% 
                  # rename that column
                  rename(name = '"Classical"')

# check if there are duplicates
dupes <- rock_wfeat %>%
  get_dupes(id)

classical_rc <- classical %>% 
  select(danceability, valence, speechiness, instrumentalness, acousticness, liveness, energy) %>% 
  ggRadar(colour = "white",
          # transparency
          alpha = 0.8, 
          # get rid of points
          size = 0,
          # set y axis limits
          ylim = c(0,1))+
  labs(title = "Classical",
       caption = "Source: https://developer.spotify.com",
       x = "",
       y = "") +
  # edit theme
  theme(text = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        plot.title = element_text(size = 30, family = "Helvetica Neue Bold", hjust = 0),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light", hjust = 0.5),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        plot.margin=grid::unit(c(1,1,0.5,0.5), "cm"),
        panel.grid = element_line(colour = "#f2f2f2", 
                                  size = 0.4, 
                                  linetype = 2),
        plot.background = element_rect(fill = "#D2903C"),
        panel.background = element_rect(fill = "#D2903C"),
        legend.position = "none")+
NULL
```

### Metal

```{r metal }
metal_basic <- getPlaylistSongs("spotify","37i9dQZF1DX9qNs32fujYe", token =  keys)

metal_basic <- metal_basic %>%
  unique()
# get all features for that playlist

# create data set with any 1 song
metal_wfeat <- getFeatures("3bH4HzoZZFq8UpZmI2AMgV", token = keys)

# for loop all song ids from the playlist through the getFeatures function
for (i in metal_basic$id){
  metal_wfeat <- rbind(metal_wfeat, getFeatures(i, token = keys))
}
                  
# get rid of first line (that we added to set up the data frame)
metal_wfeat <- metal_wfeat[-1,]

# join playlist df and feature df to have all song info in one data set
metal <- left_join(metal_basic, metal_wfeat, by = "id") 

# fix data set
metal <- metal %>% 
                  # eliminate irrelevant columns
                  select(-uri, -analysis_url, -time_signature) %>% 
                  # add 1 columns with name for later when joining all of us 
                  cbind("metal") %>% 
                  # rename that column
                  rename(name = '"metal"')

# check if there are duplicates
dupes <- rock_wfeat %>%
  get_dupes(id)

metal_rc <- metal %>% 
  select(danceability, valence, speechiness, instrumentalness, acousticness, liveness, energy) %>% 
  ggRadar(colour = "white",
          # transparency
          alpha = 0.8, 
          # get rid of points
          size = 0,
          # set y axis limits
          ylim = c(0,1))+
  labs(title = "Metal",
       caption = "Source: https://developer.spotify.com",
       x = "",
       y = "") +
  # edit theme
  theme(text = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        plot.title = element_text(size = 30, family = "Helvetica Neue Bold", hjust = 0),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light", hjust = 0.5),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        plot.margin=grid::unit(c(1,1,0.5,0.5), "cm"),
        panel.grid = element_line(colour = "#f2f2f2", 
                                  size = 0.4, 
                                  linetype = 2),
        plot.background = element_rect(fill = "#6A1F2B"),
        panel.background = element_rect(fill = "#6A1F2B"),
        legend.position = "none")+
NULL

```

### Country

```{r country}
country_basic <- getPlaylistSongs("spotify","37i9dQZF1DX1lVhptIYRda", token =  keys)

country_basic <- country_basic %>%
  unique()
# get all features for that playlist

# create data set with any 1 song
country_wfeat <- getFeatures("3bH4HzoZZFq8UpZmI2AMgV", token = keys)

# for loop all song ids from the playlist through the getFeatures function
for (i in country_basic$id){
  country_wfeat <- rbind(country_wfeat, getFeatures(i, token = keys))
}
                  
# get rid of first line (that we added to set up the data frame)
country_wfeat <- country_wfeat[-1,]

# join playlist df and feature df to have all song info in one data set
country <- left_join(country_basic, country_wfeat, by = "id") 

# fix data set
country <- country %>% 
                  # eliminate irrelevant columns
                  select(-uri, -analysis_url, -time_signature) %>% 
                  # add 1 columns with name for later when joining all of us 
                  cbind("country") %>% 
                  # rename that column
                  rename(name = '"country"')

# check if there are duplicates
dupes <- rock_wfeat %>%
  get_dupes(id)

country_rc <- country %>% 
  select(danceability, valence, speechiness, instrumentalness, acousticness, liveness, energy) %>% 
  ggRadar(colour = "white",
          # transparency
          alpha = 0.8, 
          # get rid of points
          size = 0,
          # set y axis limits
          ylim = c(0,1))+
  labs(title = "Country",
       caption = "Source: https://developer.spotify.com",
       x = "",
       y = "") +
  # edit theme
  theme(text = element_text(colour = "white", size = 10, family = "Helvetica Neue Bold"),
        plot.title = element_text(size = 30, family = "Helvetica Neue Bold", hjust = 0),
        plot.subtitle = element_text(size = 11, family = "Helvetica Neue Light", hjust = 0.5),
        plot.caption = element_text(size = 6, family = "Helvetica Neue Light"),
        axis.title.x = element_text(size = 10, family = "Helvetica Neue Bold"),
        axis.text.x = element_text(colour = "white", size = 10, family = "Helvetica Neue Medium"),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        plot.margin=grid::unit(c(1,1,0.5,0.5), "cm"),
        panel.grid = element_line(colour = "#f2f2f2", 
                                  size = 0.4, 
                                  linetype = 2),
        plot.background = element_rect(fill = "#C54190"),
        panel.background = element_rect(fill = "#C54190"),
        legend.position = "none")+
NULL
```

### All

```{r all genres}
indie_rc
hiphop_rc
rock_rc
classical_rc
metal_rc
country_rc

#indie_rc + ggsave('indie.jpeg', height = 5, width = 5, units = 'in')
#hiphop_rc + ggsave('hiphop.jpeg', height = 5, width = 5, units = 'in')
#rock_rc + ggsave('rock.jpeg', height = 5, width = 5, units = 'in')
#classical_rc + ggsave('classial.jpeg', height = 5, width = 5, units = 'in')
#metal_rc + ggsave('metal.jpeg', height = 5, width = 5, units = 'in')
#country_rc + ggsave('country.jpeg', height = 5, width = 5, units = 'in')
```

It is clearly visible that the emotions and audio features of songs differ highly by genre. While Metal, Rock and Country are highly energetic genres, Classical music is highly acoustic and makes use of a lot of instruments. Indie music seems to keep a good balance of energetic and danceable but also acoustic and happy music. Hip Hop seems to make almost no use of instruments and if you're looking for happy music, it seems you best look for Indie, Hip Hop or Rock songs.

What other features can you find that are interesting? Any surprising ones?

Most of these features do not come as a surprise as we associate them with the respective genre - but isn't it interesting to see the data behind the stereotypes we have for different music genres and their fans?

## Time

Another highly influential factor on music and which songs or artists are popular is time and period or decade tracks were released in and listened to. 

We use the 1921-2020 data set again and build an interactive story consisting of three dashboards.You can investigate the data and find out more about it [here](https://public.tableau.com/profile/ruchen8489#!/vizhome/Group14_Spotify_ByDecade/Story?publish=yes) or by scanning this QR code:

![](time.jpeg)


We can see that songs' audio features change over time. On average, music is getting louder, more energetic, and more explicit. Meanwhile, valence, instrumentalness and speechiness are also decreasing. These plots also show the significance of certain historical events and eras; for example, in the war and post-war eras (40s and 50s) we see that music is less danceable, energetic, happy or instrumental. During the Hippie eras in the 60s and 70s, we can observe increases in music's positiveness and energy.

In the second dashboard, we can investigate which artists from different decades are still relevant today and were, therefore, also most likely most popular during those decades. Again, the relevant artists and songs change over time. Over the last 100 years, the Beatles and Led Zeppelin are people's all time favorites.

Lastly, we can look at the most prolific artists in each decade calculated by the number of tracks produced. Again, these change steadily and artists have to work a great deal (produce lots of songs!) to stay on top of the industry. Music success is short - it doesn't take long until the next song or artists hits #1 in the charts and replaces previously loved artists. 

**Feel free to investigate more yourself!**

## Location

Lastly, the region, country and/or culture is also relevant to understand music preferences.

We use data containing top hit playlists per country and built a dashboard showing streaming trends worldwide and/or per country. The file contains top 200 tracks figures (track name, artist and streaming) per day per country around the globe. You can download the data [here](https://spotifycharts.com/regional).

You can investigate the data and find out more about it [here]https://public.tableau.com/profile/sammy.chen#!/vizhome/Musictrendandtasteanalysisbycountry/Dashboard1?publish=yes) or by scanning this QR code:

![](location.jpeg)

You can click on the country you are interested in on the map and the other three plots change immediately to show daily steaming trends, most popular tracks and artists in that specific country you've chosen!

We found that steaming trends rise globally. Countries on the same continent share similar tastes - except many Western artisits such as Ed Sheeran and Ariana Grande conquer the world and are relevant in almost all countries gloablly. Meanwhile, countries speaking different languages than English tend to have further favourite songs and artists from their own language. 

It is interesting to see that one popular song is sometimes not enough to make the artist popular. For example, in Japan, Kenshi Yonezu is not even ranked among top 10 artists, but one of his songs is ranked 2# most popular. While popular artists always publish most popular tracks. In U.K., top 2 songs are produced by top 1 artist.


# Conclusion

We found that **todayâ€™s popular music is all about danceability and energy;** it is less about live music, acoustic tracks or use of actual instruments. Acoustic songs, conveying positive moods or using a lot of speech seem to negatively influence song popularity while danceable songs with high energy and explicit words seem to guarantee success.

Caution though! **Music is too diverse to be generalised in a statistical model**

In order to better understand what determines popularity and people's music taste we must understand the following:

  1. **Genre**: Music preferences differ by genre
  2. **Content**: Lyrics and their meaning highly influence songs
  3. **Time period**: Music taste and preferences evolve over time; however, some artists and songs survive time and are still relevant today; either way, *success is often short* and all artists try to survive in a highly competitive music industry
  5. **Location**: Music taste and preferences differ by country; some songs reach people worldwide while others stay local
  
We find that **there is no one way to understand and predict music preferences and popularity**

However similar we may be - remember - **everyoneâ€™s music taste is unique**!

> You can explore the data behind your favourite songs as much as you like â€“ at the end of the day, only you know what makes you like a song!

